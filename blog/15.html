<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-23 Sun 16:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SICP. 2.2.2</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="./style.css"/>
</head>
<body>
<div id="content" class="content">
<h1 class="title">SICP. 2.2.2
<br />
<span class="subtitle">2023-04-23 Sun</span>
</h1>

<div id="outline-container-org6b5df1c" class="outline-2">
<h2 id="org6b5df1c">Hierarchical Data and the Closure Property</h2>
<div class="outline-text-2" id="text-org6b5df1c">
<p>
Lists can be used to represents sequences whose elements may
themselves be sequences.
</p>

<pre class="example">
Figure 2.5: Structure formed by `(cons (list 1 2) (list 3 4))'.

                                             (3 4)
                                               |
                                               V
   ((1 2) 3 4)  +---+---+                  +---+---+     +---+---+
           ----&gt;| * | *-+-----------------&gt;| * | *-+----&gt;| * | / |
                +-|-+---+                  +-|-+---+     +-|-+---+
                  |                          |             |
                  V                          V             V
         (1 2)  +---+---+     +---+---+    +---+         +---+
           ----&gt;| * | *-+----&gt;| * | / |    | 3 |         | 4 |
                +-|-+---+     +-|-+---+    +---+         +---+
                  |             |
                  V             V
                +---+         +---+
                | 1 |         | 2 |
                +---+         +---+
</pre>

<p>
Sequences whose elements are sequences can be though of as <i>trees</i>.
</p>

<pre class="example">
Figure 2.6: The list structure in Figure 2-5 viewed as a tree.

      ((1 2) 3 4)
          /\\
         /  | \
     (1 2)  3 4
      / \
      1 2
</pre>

<blockquote>
<p>
Recursion is a natural tool for dealing with tree structures, since we
can often reduce operations on trees to operations on their branches,
which reduce in turn to operations on the branches of the branches,
and so on, until we reach the leaves of the tree. (p. 108)
</p>
</blockquote>

<p>
We can write a procedures that counts the number of leaves in tree,
somewhat similarly to what we have done when writing <code>length</code> for
counting the number of elements in a list&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">count-leaves</span> x)
  (con ((null? x) 0)
       ((not (pair? x)) 1)
       (+ (count-leaves (car x))
          (count-leaves (cdr x)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org76c6a6b" class="outline-2">
<h2 id="org76c6a6b">Exercise 2.24</h2>
<div class="outline-text-2" id="text-org76c6a6b">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
Suppose we evaluate the expression <code>(list 1 (list 2 (list 3
4)))</code>. Give the result printed by the interpreter, the corresponding
box-and-pointer structure, and the interpretation of this as a tree
(as in Figure 2.6).
</p>
</blockquote>

<p>
<b>Answer</b>:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(list 1 (list 2 (list 3 4))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; (1 (2 (3 4)))</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">box-and-pointer structure:</span>
<span style="color: #b22222;">;;</span>
<span style="color: #b22222;">;;  </span><span style="color: #b22222;">-&gt;[ | ]---&gt;[ |/]</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">|        |</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">v        v</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">1       [ | ]---&gt;[ |/]</span>
<span style="color: #b22222;">;;              </span><span style="color: #b22222;">|        |</span>
<span style="color: #b22222;">;;              </span><span style="color: #b22222;">v        v</span>
<span style="color: #b22222;">;;              </span><span style="color: #b22222;">2       [ | ]---&gt;[ |/]</span>
<span style="color: #b22222;">;;                       </span><span style="color: #b22222;">|        |</span>
<span style="color: #b22222;">;;                       </span><span style="color: #b22222;">v        v</span>
<span style="color: #b22222;">;;                       </span><span style="color: #b22222;">3        4</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">tree:</span>
<span style="color: #b22222;">;; </span>
<span style="color: #b22222;">;;        </span><span style="color: #b22222;">.</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">/ \</span>
<span style="color: #b22222;">;;      </span><span style="color: #b22222;">/   \</span>
<span style="color: #b22222;">;;     </span><span style="color: #b22222;">1     .</span>
<span style="color: #b22222;">;;          </span><span style="color: #b22222;">/ \</span>
<span style="color: #b22222;">;;         </span><span style="color: #b22222;">/   \</span>
<span style="color: #b22222;">;;        </span><span style="color: #b22222;">2     .</span>
<span style="color: #b22222;">;;             </span><span style="color: #b22222;">/ \</span>
<span style="color: #b22222;">;;            </span><span style="color: #b22222;">/   \</span>
<span style="color: #b22222;">;;           </span><span style="color: #b22222;">3     4</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8cc7617" class="outline-2">
<h2 id="org8cc7617">Exercise 2.25</h2>
<div class="outline-text-2" id="text-org8cc7617">
<p>
<b>Exercise</b>:
</p>


<blockquote>
<p>
Give combinations of <code>cars</code> and <code>cdrs</code> that will pick 7 from each of
the following lists:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">setq</span> x '(1 3 (5 7) 9))
(car (cdr (car (cdr (cdr x))))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 7</span>

(<span style="color: #a020f0;">setq</span> x '((7)))
(car (car x)) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 7</span>

(<span style="color: #a020f0;">setq</span> x '(1 (2 (3 (4 (5 (6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr x)))))))))))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 7</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaacb0b9" class="outline-2">
<h2 id="orgaacb0b9">Exercise 2.26</h2>
<div class="outline-text-2" id="text-orgaacb0b9">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
Suppose we define x and y to be two lists:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">x</span> (list 1 2 3))
(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">y</span> (list 4 5 6))
</pre>
</div>

<p>
What result is printed by the interpreter in response to evaluating
each of the following expressions:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(append x y)
(cons x y)
(list x y)
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #b22222;">;; </span><span style="color: #b22222;">(append x y) =&gt; (1 2 3 4 5 6)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">(cons x y)   =&gt; ((1 2 3) 4 5 6)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">(list x y)   =&gt; ((1 2 3) (4 5 6))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc0cf4f" class="outline-2">
<h2 id="orgfc0cf4f">Exercise 2.27</h2>
<div class="outline-text-2" id="text-orgfc0cf4f">
<p>
<b>Exercise</b>:
</p>
<blockquote>
<p>
Modify your reverse procedure of Exercise 2.18 to produce a
deep-reverse procedure that takes a list as argument and returns as
its value the list with its elements reversed and with all sublists
deep-reversed as well. For example,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">x</span>
  (list (list 1 2) (list 3 4)))

x
((1 2) (3 4))

(reverse x)
((3 4) (1 2))

(deep-reverse x)
((4 3) (2 1))
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<p>
Modification of the iterative-process-evolving procedure previously provided:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">deep-reverse</span> x)
  (<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">iter</span> x result)
    (<span style="color: #a020f0;">cond</span> ((null? x) result)
          ((not (pair? x)) x)
          (<span style="color: #a020f0;">else</span> (iter (cdr x)
                      (cons (iter (car x) nil) result))))) (iter x nil))
</pre>
</div>

<p>
Modification of the recursive-process-evolving procedure previously
provided:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">deep-reverse</span> t)
  (<span style="color: #a020f0;">cond</span> ((null? t) nil)
        ((pair? t) (append (list (deep-reverse (cdr t)))
                           (list (deep-reverse (car t)))))
        (<span style="color: #a020f0;">else</span> (list t))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org75785ba" class="outline-2">
<h2 id="org75785ba">Exercise 2.28</h2>
<div class="outline-text-2" id="text-org75785ba">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
Write a procedure <code>fringe</code> that takes as argument a tree (represented
as a list) and returns a list whose elements are all the leaves of the
tree arranged in left-to-right order. For example,
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> <span style="color: #0000ff;">x</span>
  (list (list 1 2) (list 3 4)))

(fringe x)
(1 2 3 4)

(fringe (list x x))
(1 2 3 4 1 2 3 4)
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">fringe</span> t)
  (<span style="color: #a020f0;">cond</span> ((null? t) nil)
        ((pair? t) (append (fringe (car t))
                           (fringe (cdr t))))
        (<span style="color: #a020f0;">else</span> (list t))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org85f76e5" class="outline-2">
<h2 id="org85f76e5">Exercise 2.29</h2>
<div class="outline-text-2" id="text-org85f76e5">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
A binary mobile consists of two branches, a left branch and a right
branch. Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile. We can represent a binary
mobile using compound data by constructing it from two branches (for
example, using <code>list</code>):
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-mobile</span> left right)
  (list left right))
</pre>
</div>

<p>
A branch is constructed from a <code>length</code> (which must be a number)
together with a <code>structure</code>, which may be either a number (representing
a simple weight) or another mobile:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-branch</span> length structure)
  (list length structure))
</pre>
</div>

<ol class="org-ol">
<li>Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>,
which return the branches of a mobile, and <code>branch-length</code> and
<code>branch-structure</code>, which return the components of a branch.</li>
<li>Using your selectors, define a procedure <code>total-weight</code> that returns
the total weight of a mobile.</li>
<li>A mobile is said to be <i>balanced</i> if the torque applied by its
top-left branch is equal to that applied by its top-right branch
(that is, if the length of the left rod multiplied by the weight
hanging from that rod is equal to the corresponding product for the
right side) and if each of the submobiles hanging off its branches
is balanced. Design a predicate that tests whether a binary mobile
is balanced.</li>
<li><p>
Suppose we change the representation of mobiles so that the
constructors are
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-mobile</span> left right)
  (cons left right))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-branch</span> length structure)
  (cons length structure))
</pre>
</div>

<p>
How much do you need to change your programs to convert to the new
representation?
</p></li>
</ol>
</blockquote>

<p>
<b>Answer</b>:
</p>

<p>
1:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-mobile</span> left right)
  (list left right))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-branch</span> length structure)
  (list length structure))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">left-branch</span> mobile)
  (car mobile))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">right-branch</span> mobile)
  (car (cdr mobile)))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">branch-length</span> branch)
  (car branch))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">branch-structure</span> branch)
  (car (cdr branch)))

</pre>
</div>

<p>
2:
</p>

<ul class="org-ul">
<li>The total weight of a mobile is the total weight of the left branch
plus the total weight of the left branch. (In this context,
something is a branch if its car is a pair.)</li>

<li>The total weight of branch whose branch structure is a mobile, is
the the total weight of the mobile. (We can check whether a the
branch structure of a mobile is a mobile by checking whether is a
pair).</li>

<li>The total weight of a branch whose branch structure is a weight, is
the the weight.</li>
</ul>

<p>
With these three rules above we can write our function:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">total-weight</span> x)
  (<span style="color: #a020f0;">cond</span> ((pair? (car x)) (+ (total-weight (left-branch x))
                            (total-weight (right-branch x))))
        ((pair? (branch-structure x)) (total-weight (branch-structure x)))
        ((not (pair? (branch-structure x))) (branch-structure x))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">(make-mobile (make-branch 1 2) (make-branch 3 4)) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; ((1 2) (3 4))</span>
(left-branch (make-mobile (make-branch 1 2) (make-branch 3 4))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; (1 2)</span>
(right-branch (make-mobile (make-branch 1 2) (make-branch 3 4))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; (3 4)</span>
(branch-structure (right-branch (make-mobile (make-branch 1 2) (make-branch 3 4)))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 4</span>
(total-weight (make-mobile (make-branch 1 2) (make-branch 3 4))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 6</span>
(total-weight (make-mobile (make-branch 1 2) (make-mobile (make-branch 1 2) (make-branch 3 4)))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 8</span>
(total-weight (make-mobile (make-mobile (make-branch 1 2) (make-branch 3 4)) (make-mobile (make-branch 1 2) (make-branch 3 4)))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; 12</span>
</pre>
</div>

<p>
3:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">torque</span> branch)
  (* (branch-length branch)
     (total-weight branch)))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">isBalanced</span> mobile)
  (<span style="color: #a020f0;">cond</span> ((not (pair? (branch-structure (right-branch mobile))))
         (= (torque (left-branch mobile))
            (torque (right-branch mobile))))
        (<span style="color: #a020f0;">else</span> (<span style="color: #a020f0;">and</span> (= (torque (left-branch mobile))
                      (torque (right-branch mobile)))
                   (isBalanced (branch-structure (right-branch mobile)))))))

(isBalanced (make-mobile (make-branch 2 2) (make-branch 2 2))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; #t</span>
(isBalanced (make-mobile (make-branch 2 2) (make-branch 2 3))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; #f</span>

(isBalanced (make-mobile (make-branch 2 2)
                         (make-branch 2 (make-mobile (make-branch 1 1)
                                         (make-branch 1 1 ))))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; #t</span>
(isBalanced (make-mobile (make-branch 2 2)
                         (make-branch 2 (make-mobile (make-branch 2 1)
                                                     (make-branch 1 1 ))))) <span style="color: #b22222;">;; </span><span style="color: #b22222;">=&gt; #f</span>
</pre>
</div>

<p>
4:
</p>

<p>
If we changed the representation of mobiles so to have
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-mobile</span> left right)
  (cons left right))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">make-branch</span> length structure)
  (cons length structure))
</pre>
</div>
<p>
then, we would only need to change the selectors <code>right-branch</code> and
<code>branch-structure</code>:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">right-branch</span> mobile)
  (cdr mobile))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">branch-structure</span> branch)
  (cdr branch))
</pre>
</div>

<p>
Both <code>left-branch</code> and <code>branch-length</code> would still work, and neither
<code>total-weight</code> nor <code>isBalanced</code> depend on the details of how mobiles
and branchs are constructed.
</p>
</div>
</div>

<div id="outline-container-org7e34425" class="outline-2">
<h2 id="org7e34425">Mapping over trees</h2>
<div class="outline-text-2" id="text-org7e34425">
<blockquote>
<p>
Just as <code>map</code> is a powerful abstraction for dealing with sequences,
<code>map</code> together with recursion is a powerful abstraction for dealing
with trees. (p. 112)
</p>
</blockquote>

<p>
The following function takes a tree whose leaves are numbers and
returns it with each leaf multiplied by a factor:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">scale-tree</span> tree factor)
  (<span style="color: #a020f0;">cond</span> ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (<span style="color: #a020f0;">else</span> (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factlr)))))
</pre>
</div>
<p>
<code>scale-tree</code> can be rewritten using <code>map</code>:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">scale-tree</span> tree factor)
  (<span style="color: #a020f0;">map</span> (<span style="color: #a020f0;">lambda</span> (sub-tree)
         (<span style="color: #a020f0;">if</span> (pair? subtree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
</pre>
</div>
</div>
</div>

<div id="outline-container-org9bd07cb" class="outline-2">
<h2 id="org9bd07cb">Exercise 2.30</h2>
<div class="outline-text-2" id="text-org9bd07cb">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
Define a procedure <code>square-tree</code> analogous to the <code>square-list</code>
procedure of Exercise 2.21. That is, <code>square-tree</code> should behave as
follows:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
(1 (4 (9 16) 25) (36 49))
</pre>
</div>

<p>
Define square-tree both directly (i.e., without using any higher-order
procedures) and also by using map and recursion.
</p>
</blockquote>

<p>
<b>Answer</b>:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">square</span> x) (* x x))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">square-tree</span> tree)
  (<span style="color: #a020f0;">cond</span> ((null? tree) nil)
        ((not (pair? tree)) (square tree))
        (<span style="color: #a020f0;">else</span> (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))

(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">square-tree</span> tree)
  (<span style="color: #a020f0;">map</span> (<span style="color: #a020f0;">lambda</span> (sub-tree)
         (<span style="color: #a020f0;">if</span> (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
</pre>
</div>
</div>
</div>

<div id="outline-container-org24673c9" class="outline-2">
<h2 id="org24673c9">Exercise 2.31</h2>
<div class="outline-text-2" id="text-org24673c9">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
Abstract your answer to Exercise 2.30 to produce a procedure tree-map
with the property that square-tree could be defined as
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">square-tree</span> tree)
  (tree-map square tree))
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<p>
``Directly'':
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">tree-map</span> proc tree)
  (<span style="color: #a020f0;">cond</span> ((null? tree) nil)
        ((not (pair? tree)) (proc tree))
        (<span style="color: #a020f0;">else</span> (cons (tree-map proc (car tree))
                    (tree-map proc (cdr tree))))))

</pre>
</div>

<p>
Using map:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">tree-map</span> proc tree)
  (<span style="color: #a020f0;">map</span> (<span style="color: #a020f0;">lambda</span> (sub-tree)
         (<span style="color: #a020f0;">if</span> (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea717d8" class="outline-2">
<h2 id="orgea717d8">Exercise 2.32</h2>
<div class="outline-text-2" id="text-orgea717d8">
<p>
<b>Exercise</b>:
</p>

<blockquote>
<p>
We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists. For
example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3)
(2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition
of a procedure that generates the set of subsets of a set and give a
clear explanation of why it works:
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">subsets</span> s)
  (<span style="color: #a020f0;">if</span> (null? s)
      (list nil)
      (<span style="color: #a020f0;">let</span> ((rest (subsets (cdr s))))
        (append rest (<span style="color: #a020f0;">map</span> &#10216;??&#10217; rest)))))
</pre>
</div>
</blockquote>

<p>
<b>Answer</b>:
</p>

<p>
The first guess was correct:
</p>
<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">subsets</span> s)
  (<span style="color: #a020f0;">if</span> (null? s)
      (list nil)
      (<span style="color: #a020f0;">let</span> ((rest (subsets (cdr s))))
        (append rest (<span style="color: #a020f0;">map</span> (<span style="color: #a020f0;">lambda</span> (x)
                            (cons (car s) x))
                          rest)))))
</pre>
</div>

<p>
Let's have a look at the evolution of the process evolved by subsets
(as a tree):
</p>
<pre class="example">
                                           (subsets (list 1 2 3))
                                                   |
                                                 append
                                      ____________/ \____________
                                     /                           \
                              (subsets '(2 3))                map consing 1
                                    |                             |
                                  append                  (subsets '(2 3))
                       ____________/ \____________                |
                      /                           \              ...
              (subsets '(3))                 map consing 2
       ____________/ \____________                |
      /                           \         (subsets '(3))
(subsets '())             map consing 3           |
      |                           |              ...
   '(nil)                  (subsets '())
                                  |
                               '(nil)
</pre>

<p>
We can see that for each list with one element <i>a</i>, <code>subsets</code> will
return, correctly, a list <i>l1</i> whose members are the empty list and
<i>a</i>:
</p>
<pre class="example">
(a) =&gt; ( () (a) )
</pre>

<p>
What if we add one element <i>b</i> to the list with <i>a</i>? The right answer
must be the list whose members are the members in <i>l1</i> plus each
member of <i>l1</i> with <i>b</i> in it:
</p>
<pre class="example">
(a b) =&gt; ( () (a) (b) (a b))
</pre>
<p>
This is exactly what <code>subsets</code> does: it returns the list (created by
appending) of all members of <i>l1</i> <b>and</b> each each member of <i>l1</i> with b in
it (that is, the result of applying <code>append</code> to <i>l1</i> and the map of
<i>l1</i> in which we cons <code>b</code> in each element of <i>l1</i>).
</p>

<p>
What if we add one element <i>c</i> to the list with <i>a</i> and <i>b</i>?
Analogously&#x2026;
</p>

<div style="text-align: center;">
<a href="./posts.html">‚Üê</a>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>Send me an <a href="mailto:giulio.pietroiusti@gmail.com">email</a> for comments.</p> <p>Created with <span class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</span></p>
</div>
</body>
</html>
